// Code generated by entc, DO NOT EDIT.

package ogent

import (
	"context"
	"net/http"

	"github.com/go-faster/jx"
	"github.com/kirbby/Menu_Selector/ent"
	"github.com/kirbby/Menu_Selector/ent/guest"
	"github.com/kirbby/Menu_Selector/ent/menuitem"
)

// OgentHandler implements the ogen generated Handler interface and uses Ent as data layer.
type OgentHandler struct {
	client *ent.Client
}

// NewOgentHandler returns a new OgentHandler.
func NewOgentHandler(c *ent.Client) *OgentHandler { return &OgentHandler{c} }

// rawError renders err as json string.
func rawError(err error) jx.Raw {
	var e jx.Encoder
	e.Str(err.Error())
	return e.Bytes()
}

// CreateGuest handles POST /guests requests.
func (h *OgentHandler) CreateGuest(ctx context.Context, req CreateGuestReq) (CreateGuestRes, error) {
	b := h.client.Guest.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetEmail(req.Email)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Guest.Query().Where(guest.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGuestCreate(e), nil
}

// ReadGuest handles GET /guests/{id} requests.
func (h *OgentHandler) ReadGuest(ctx context.Context, params ReadGuestParams) (ReadGuestRes, error) {
	q := h.client.Guest.Query().Where(guest.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewGuestRead(e), nil
}

// UpdateGuest handles PATCH /guests/{id} requests.
func (h *OgentHandler) UpdateGuest(ctx context.Context, req UpdateGuestReq, params UpdateGuestParams) (UpdateGuestRes, error) {
	b := h.client.Guest.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Email.Get(); ok {
		b.SetEmail(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.Guest.Query().Where(guest.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewGuestUpdate(e), nil
}

// DeleteGuest handles DELETE /guests/{id} requests.
func (h *OgentHandler) DeleteGuest(ctx context.Context, params DeleteGuestParams) (DeleteGuestRes, error) {
	err := h.client.Guest.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteGuestNoContent), nil

}

// ListGuest handles GET /guests requests.
func (h *OgentHandler) ListGuest(ctx context.Context, params ListGuestParams) (ListGuestRes, error) {
	q := h.client.Guest.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewGuestLists(es)
	return (*ListGuestOKApplicationJSON)(&r), nil
}

// CreateMenuItem handles POST /menu-items requests.
func (h *OgentHandler) CreateMenuItem(ctx context.Context, req CreateMenuItemReq) (CreateMenuItemRes, error) {
	b := h.client.MenuItem.Create()
	// Add all fields.
	b.SetName(req.Name)
	b.SetDescription(req.Description)
	b.SetImage(req.Image)
	b.SetCategoryId(req.CategoryId)
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MenuItem.Query().Where(menuitem.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMenuItemCreate(e), nil
}

// ReadMenuItem handles GET /menu-items/{id} requests.
func (h *OgentHandler) ReadMenuItem(ctx context.Context, params ReadMenuItemParams) (ReadMenuItemRes, error) {
	q := h.client.MenuItem.Query().Where(menuitem.IDEQ(params.ID))
	e, err := q.Only(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return NewMenuItemRead(e), nil
}

// UpdateMenuItem handles PATCH /menu-items/{id} requests.
func (h *OgentHandler) UpdateMenuItem(ctx context.Context, req UpdateMenuItemReq, params UpdateMenuItemParams) (UpdateMenuItemRes, error) {
	b := h.client.MenuItem.UpdateOneID(params.ID)
	// Add all fields.
	if v, ok := req.Name.Get(); ok {
		b.SetName(v)
	}
	if v, ok := req.Description.Get(); ok {
		b.SetDescription(v)
	}
	if v, ok := req.Image.Get(); ok {
		b.SetImage(v)
	}
	if v, ok := req.CategoryId.Get(); ok {
		b.SetCategoryId(v)
	}
	// Add all edges.
	// Persist to storage.
	e, err := b.Save(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	// Reload the entity to attach all eager-loaded edges.
	q := h.client.MenuItem.Query().Where(menuitem.ID(e.ID))
	e, err = q.Only(ctx)
	if err != nil {
		// This should never happen.
		return nil, err
	}
	return NewMenuItemUpdate(e), nil
}

// DeleteMenuItem handles DELETE /menu-items/{id} requests.
func (h *OgentHandler) DeleteMenuItem(ctx context.Context, params DeleteMenuItemParams) (DeleteMenuItemRes, error) {
	err := h.client.MenuItem.DeleteOneID(params.ID).Exec(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsConstraintError(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	return new(DeleteMenuItemNoContent), nil

}

// ListMenuItem handles GET /menu-items requests.
func (h *OgentHandler) ListMenuItem(ctx context.Context, params ListMenuItemParams) (ListMenuItemRes, error) {
	q := h.client.MenuItem.Query()
	page := 1
	if v, ok := params.Page.Get(); ok {
		page = v
	}
	itemsPerPage := 30
	if v, ok := params.ItemsPerPage.Get(); ok {
		itemsPerPage = v
	}
	q.Limit(itemsPerPage).Offset((page - 1) * itemsPerPage)

	es, err := q.All(ctx)
	if err != nil {
		switch {
		case ent.IsNotFound(err):
			return &R404{
				Code:   http.StatusNotFound,
				Status: http.StatusText(http.StatusNotFound),
				Errors: rawError(err),
			}, nil
		case ent.IsNotSingular(err):
			return &R409{
				Code:   http.StatusConflict,
				Status: http.StatusText(http.StatusConflict),
				Errors: rawError(err),
			}, nil
		default:
			// Let the server handle the error.
			return nil, err
		}
	}
	r := NewMenuItemLists(es)
	return (*ListMenuItemOKApplicationJSON)(&r), nil
}
